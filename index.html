<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>AR mit adaptivem Retikel</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.125.0/build/three.module.js';
  import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.125.0/examples/jsm/webxr/ARButton.js';

  class App {
    constructor() {
      const container = document.createElement('div');
      document.body.appendChild(container);

      this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      this.camera.position.set(0, 1.6, 0);

      this.scene = new THREE.Scene();

      const ambient = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      ambient.position.set(0.5, 1, 0.25);
      this.scene.add(ambient);

      this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.xr.enabled = true;
      container.appendChild(this.renderer.domElement);

      // AR-Button hinzufügen
      document.body.appendChild(ARButton.createButton(this.renderer, { requiredFeatures: ['hit-test'] }));

      // Erstelle den Retikel: standardmäßig horizontal (um -90° um die X-Achse rotiert)
      this.reticle = new THREE.Mesh(
        new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      this.reticle.matrixAutoUpdate = false;
      this.reticle.visible = false;
      this.scene.add(this.reticle);

      // Setup für XR und Hit-Test
      this.setupXR();

      // Beispiel: Ein einfacher roter Kegel als Platzhaltermodell
      this.createCone();

      window.addEventListener('resize', this.resize.bind(this));
    }

    setupXR() {
      const self = this;
      this.hitTestSourceRequested = false;
      this.hitTestSource = null;

      // Beim Select-Event wird der Kegel an die Position des Retikels gesetzt
      function onSelect() {
        if (!self.cone) return;
        if (self.reticle.visible) {
          self.cone.position.setFromMatrixPosition(self.reticle.matrix);
          self.cone.visible = true;
        }
      }

      this.controller = this.renderer.xr.getController(0);
      this.controller.addEventListener('select', onSelect);
      this.scene.add(this.controller);
    }

    resize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    createCone() {
      // Erstelle einen roten Kegel als einfaches Modell
      const geometry = new THREE.ConeGeometry(0.1, 0.2, 32);
      const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      this.cone = new THREE.Mesh(geometry, material);
      this.cone.visible = false;
      this.scene.add(this.cone);
      // Starte die Render-Schleife
      this.renderer.setAnimationLoop(this.render.bind(this));
    }

    requestHitTestSource() {
      const self = this;
      const session = this.renderer.xr.getSession();

      session.requestReferenceSpace('viewer').then(function(referenceSpace) {
        session.requestHitTestSource({ space: referenceSpace }).then(function(source) {
          self.hitTestSource = source;
        });
      });

      session.addEventListener('end', function () {
        self.hitTestSourceRequested = false;
        self.hitTestSource = null;
      });

      this.hitTestSourceRequested = true;
    }

    getHitTestResults(frame) {
      const hitTestResults = frame.getHitTestResults(this.hitTestSource);
      if (hitTestResults.length) {
        const referenceSpace = this.renderer.xr.getReferenceSpace();
        const hit = hitTestResults[0];
        const pose = hit.getPose(referenceSpace);
        
        // Lese die Treffer-Matrix aus
        const hitMatrix = new THREE.Matrix4().fromArray(pose.transform.matrix);
        
        // Extrahiere den Up-Vektor (zweite Spalte der Matrix)
        const up = new THREE.Vector3();
        up.setFromMatrixColumn(hitMatrix, 1).normalize();

        // Berechne den Skalarprodukt mit dem Welt-Up-Vektor (0,1,0)
        const dot = up.dot(new THREE.Vector3(0, 1, 0));
        
        // Wenn dot nahe 1 ist, liegt eine horizontale Fläche vor.
        // Liegt der Wert deutlich darunter (z. B. < 0.5), gehen wir davon aus, dass
        // die horizontale Fläche zu Ende ist und eine vertikale Fläche vorliegt.
        if (dot < 0.5) {
          // Drehung um 90° (π/2) um die X-Achse: das Retikel kippt ins Vertikale.
          hitMatrix.multiply(new THREE.Matrix4().makeRotationX(Math.PI / 2));
        }
        
        this.reticle.matrix.copy(hitMatrix);
        this.reticle.visible = true;
      } else {
        this.reticle.visible = false;
      }
    }

    render(timestamp, frame) {
      if (frame) {
        if (!this.hitTestSourceRequested) this.requestHitTestSource();
        if (this.hitTestSource) this.getHitTestResults(frame);
      }
      this.renderer.render(this.scene, this.camera);
    }
  }

  // Erzeuge die App-Instanz
  const app = new App();
</script>
</body>
</html>
