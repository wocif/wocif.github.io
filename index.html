<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>AR Rechteck mit Retikel, Drehfunktion und B-Taste</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.125.0/build/three.module.js';
  import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.125.0/examples/jsm/webxr/ARButton.js';

  class App {
    constructor() {
      const container = document.createElement('div');
      document.body.appendChild(container);

      this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      this.camera.position.set(0, 1.6, 0);

      this.scene = new THREE.Scene();

      const ambient = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      ambient.position.set(0.5, 1, 0.25);
      this.scene.add(ambient);

      this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.xr.enabled = true;
      container.appendChild(this.renderer.domElement);

      // AR-Button hinzufügen
      document.body.appendChild(ARButton.createButton(this.renderer, { requiredFeatures: ['hit-test'] }));

      // Erstelle den Retikel: Ein grüner Ring, der initial unsichtbar ist.
      this.reticle = new THREE.Mesh(
        new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      this.reticle.matrixAutoUpdate = false;
      this.reticle.visible = false;
      this.scene.add(this.reticle);

      // Setup XR und Hit-Test
      this.setupXR();

      // Erzeuge das Rechteck (als Plane) – zunächst unsichtbar
      this.createRectangle();

      // Zustand für die B-Taste (um Mehrfachauslösungen zu vermeiden)
      this.bPressed = false;

      window.addEventListener('resize', this.resize.bind(this));
    }

    setupXR() {
      const self = this;
      this.hitTestSourceRequested = false;
      this.hitTestSource = null;

      // Beim Tippen (Select):
      // - Ist das Rechteck noch nicht sichtbar, wird es an der Retikel-Position platziert.
      // - Ist es bereits sichtbar, wird es um 15° um die Y-Achse rotiert.
      function onSelect() {
        if (!self.rectangle) return;
        if (!self.rectangle.visible) {
          self.rectangle.position.setFromMatrixPosition(self.reticle.matrix);
          // Optionale Ausrichtung: Übernehme ggf. die Y-Rotation des Retikels
          self.rectangle.rotation.y = self.reticle.rotation.y;
          self.rectangle.visible = true;
        } else {
          self.rectangle.rotation.y += THREE.Math.degToRad(15);
        }
      }

      this.controller = this.renderer.xr.getController(0);
      this.controller.addEventListener('select', onSelect);
      this.scene.add(this.controller);
    }

    resize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    createRectangle() {
      // Erzeuge ein Rechteck (PlaneGeometry) mit einer Größe von 0.4 x 0.2 Meter
      const geometry = new THREE.PlaneGeometry(0.4, 0.2);
      const material = new THREE.MeshStandardMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
      this.rectangle = new THREE.Mesh(geometry, material);
      this.rectangle.visible = false;
      this.scene.add(this.rectangle);
      // Starte die Render-Schleife
      this.renderer.setAnimationLoop(this.render.bind(this));
    }

    requestHitTestSource() {
      const self = this;
      const session = this.renderer.xr.getSession();

      session.requestReferenceSpace('viewer').then(function(referenceSpace) {
        session.requestHitTestSource({ space: referenceSpace }).then(function(source) {
          self.hitTestSource = source;
        });
      });

      session.addEventListener('end', function () {
        self.hitTestSourceRequested = false;
        self.hitTestSource = null;
      });

      this.hitTestSourceRequested = true;
    }

    getHitTestResults(frame) {
      const hitTestResults = frame.getHitTestResults(this.hitTestSource);
      if (hitTestResults.length) {
        const referenceSpace = this.renderer.xr.getReferenceSpace();
        const hit = hitTestResults[0];
        const pose = hit.getPose(referenceSpace);
        this.reticle.visible = true;
        this.reticle.matrix.fromArray(pose.transform.matrix);
      } else {
        this.reticle.visible = false;
      }
    }

    render(timestamp, frame) {
      if (frame) {
        if (!this.hitTestSourceRequested) this.requestHitTestSource();
        if (this.hitTestSource) this.getHitTestResults(frame);
      }
      
      // Prüfe, ob der B-Button (angenommen Button-Index 1) auf dem rechten Controller gedrückt wird.
      const session = this.renderer.xr.getSession();
      if (session) {
        const inputSources = session.inputSources;
        for (const inputSource of inputSources) {
          // Wir gehen davon aus, dass der rechte Controller die Eigenschaft handedness === 'right' hat
          if (inputSource.gamepad && inputSource.handedness === 'right') {
            const gamepad = inputSource.gamepad;
            // Prüfe, ob der B-Button vorhanden ist (angenommen Index 1)
            if (gamepad.buttons.length > 1) {
              if (gamepad.buttons[1].pressed && !this.bPressed) {
                // B-Taste wurde gerade gedrückt.
                if (this.rectangle.visible) {
                  // Zurück in den Platzierungsmodus: Das Rechteck wird ausgeblendet.
                  this.rectangle.visible = false;
                }
                this.bPressed = true;
              } else if (!gamepad.buttons[1].pressed) {
                this.bPressed = false;
              }
            }
          }
        }
      }
      
      this.renderer.render(this.scene, this.camera);
    }
  }

  // Erzeuge die App-Instanz.
  const app = new App();
</script>
</body>
</html>
