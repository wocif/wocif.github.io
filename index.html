<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>AR Fenster / Portal Demo</title>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.125.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.1250/examples/jsm/webxr/ARButton.js';

      class App {
        constructor() {
          const container = document.createElement('div');
          document.body.appendChild(container);

          this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
          this.scene = new THREE.Scene();

          const ambient = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
          this.scene.add(ambient);

          this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.xr.enabled = true;
          container.appendChild(this.renderer.domElement);

          document.body.appendChild(ARButton.createButton(this.renderer, { requiredFeatures: ['hit-test'] }));

          // Reticle zur Platzierung via Hit-Test
          this.reticle = new THREE.Mesh(
            new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x00ff00 })
          );
          this.reticle.matrixAutoUpdate = false;
          this.reticle.visible = false;
          this.scene.add(this.reticle);

          this.setupXR();
          this.createRectangle();

          // Zustände: 0: Platzieren, 1: Rotieren, 2: Höhe, 3: Skalieren, 4: Portal aktiv
          this.state = 0;
          this.portalActive = false;

          // Variablen für das Portal (separate Szene)
          this.portalScene = null;
          this.portalCamera = null;
          this.portalRenderTarget = null;

          this.renderer.setAnimationLoop(this.render.bind(this));
        }

        setupXR() {
          this.hitTestSourceRequested = false;
          this.hitTestSource = null;

          this.controller = this.renderer.xr.getController(0);
          this.controller.addEventListener('select', this.onSelect.bind(this));
          this.controller.addEventListener('squeezestart', this.onSqueeze.bind(this));
          this.scene.add(this.controller);
        }

        createRectangle() {
          // Ursprüngliches Rechteck (Fenster), das manipuliert wird
          const geometry = new THREE.PlaneGeometry(0.4, 0.2);
          this.originalMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
          this.rectangle = new THREE.Mesh(geometry, this.originalMaterial);
          this.rectangle.visible = false;
          this.scene.add(this.rectangle);
        }

        onSqueeze() {
          // Squeeze wechselt einen Zustand zurück (nur wenn nicht bereits Portal aktiv)
          if (!this.portalActive && this.state !== 0) {
            this.state -= 1;
          }
          if (this.state === 0) {
            this.rectangle.visible = false;
          }
        }

        onSelect() {
          if (this.state === 0) { // Platzierung: Setze Position vom Reticle
            this.rectangle.position.setFromMatrixPosition(this.reticle.matrix);
            this.rectangle.visible = true;
            this.state = 1;
          } else if (this.state === 1) { // Rotation
            this.state = 2;
          } else if (this.state === 2) { // Höhe anpassen
            this.state = 3;
          } else if (this.state === 3) { // Skalierung abschließen und Portal aktivieren
            this.state = 4;
            this.activatePortal();
          }
        }

        // Portal aktivieren: Erzeuge separate Szene, Kamera und ein Render-Target.
        activatePortal() {
          this.portalActive = true;
          // Erstelle eine neue Szene für den 3D-Welt-Inhalt
          this.portalScene = new THREE.Scene();
          // Beispiel: Einfacher rotierender Würfel in der Portal-Szene
          const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
          const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          this.portalCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
          this.portalScene.add(this.portalCube);

          // Füge Licht zur Portal-Szene hinzu
          const ambientPortal = new THREE.AmbientLight(0xffffff, 0.8);
          this.portalScene.add(ambientPortal);
          const directionalPortal = new THREE.DirectionalLight(0xffffff, 0.5);
          directionalPortal.position.set(1, 1, 1);
          this.portalScene.add(directionalPortal);

          // Erstelle eine Kamera für die Portal-Szene (Positionierung kann weiter angepasst werden)
          this.portalCamera = new THREE.PerspectiveCamera(70, 1, 0.01, 20);
          this.portalCamera.position.set(0, 0, 2);

          // Erstelle ein Render-Target, in das die Portal-Szene gerendert wird
          this.portalRenderTarget = new THREE.WebGLRenderTarget(512, 512);

          // Ändere das Material des Rechtecks, sodass es das Render-Target als Texture zeigt
          this.rectangle.material = new THREE.MeshBasicMaterial({
            map: this.portalRenderTarget.texture,
            side: THREE.DoubleSide
          });

          console.log('Portal aktiviert!');
        }

        requestHitTestSource() {
          const session = this.renderer.xr.getSession();
          session.requestReferenceSpace('viewer').then(refSpace => {
            session.requestHitTestSource({ space: refSpace }).then(source => {
              this.hitTestSource = source;
            });
          });
          session.addEventListener('end', () => {
            this.hitTestSourceRequested = false;
            this.hitTestSource = null;
          });
          this.hitTestSourceRequested = true;
        }

        getHitTestResults(frame) {
          const hitTestResults = frame.getHitTestResults(this.hitTestSource);
          if (hitTestResults.length) {
            const referenceSpace = this.renderer.xr.getReferenceSpace();
            const pose = hitTestResults[0].getPose(referenceSpace);
            this.reticle.visible = true;
            this.reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            this.reticle.visible = false;
          }
        }

        render(timestamp, frame) {
          if (frame) {
            if (!this.hitTestSourceRequested) this.requestHitTestSource();
            if (this.hitTestSource) this.getHitTestResults(frame);
          }

          const session = this.renderer.xr.getSession();
          if (session) {
            for (const inputSource of session.inputSources) {
              if (inputSource.gamepad) {
                const gamepad = inputSource.gamepad;
                const xAxis = gamepad.axes[2]; // Daumenstick horizontal
                const yAxis = gamepad.axes[3]; // Daumenstick vertikal
                // Anhand des aktuellen Zustands wird das Rechteck manipuliert:
                if (this.state === 1) { // Rotation
                  this.rectangle.rotation.y += xAxis * 0.025;
                } else if (this.state === 2) { // Höheneinstellung
                  this.rectangle.position.y += yAxis * 0.05;
                } else if (this.state === 3) { // Skalierung
                  const scale = Math.max(0.1, this.rectangle.scale.x + yAxis * 0.02);
                  this.rectangle.scale.set(scale, scale, scale);
                }
              }
            }
          }

          // Falls das Portal aktiviert wurde, rendern wir zuerst die Portal-Szene in das Render-Target.
          if (this.portalActive) {
            // Beispiel: Einfacher Würfel, der rotiert
            this.portalCube.rotation.y += 0.01;
            // Optional: Portalkamera kann an das Rechteck (Portal) gekoppelt werden, z. B. so, dass sich der Blickwinkel ändert
            // Für diese Demo bleibt die Portalkamera statisch

            // Rendern in das Ziel-RenderTarget
            this.renderer.setRenderTarget(this.portalRenderTarget);
            this.renderer.render(this.portalScene, this.portalCamera);
            this.renderer.setRenderTarget(null);
          }

          // Rendern der Hauptszene (AR-Szene)
          this.renderer.render(this.scene, this.camera);
        }
      }

      new App();
    </script>
  </body>
</html>
